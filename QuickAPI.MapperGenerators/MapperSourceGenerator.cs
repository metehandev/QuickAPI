using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace QuickAPI.MapperGenerators;

[Generator]
public class MapperSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register our syntax receiver that collects candidate classes.
        context.RegisterForSyntaxNotifications(() => new MapperSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not MapperSyntaxReceiver receiver)
            return;

        // Loop over each candidate partial class matching our naming convention.
        foreach (var candidate in receiver.CandidateMapperDeclarations)
        {
            var candidateName = candidate.Identifier.Text;
            var parts = candidateName.Split('_');
            if (parts.Length < 3)
                continue; // naming convention not followed

            var modelName = parts[1];
            var dtoName = parts[2];

            // Try to find the model and dto symbols in the compilation.
            var modelSymbol = FindTypeByName(context.Compilation, modelName);
            var dtoSymbol = FindTypeByName(context.Compilation, dtoName);

            if (modelSymbol == null || dtoSymbol == null)
            {
                // Optionally report a diagnostic here if types cannot be found.
                continue;
            }

            // Determine the namespace in which to generate the code.
            var namespaceName = "AutoGeneratedMappers";
            if (candidate.Parent is NamespaceDeclarationSyntax ns)
            {
                namespaceName = ns.Name.ToString();
            }

            // Generate the mapper source with property-based mapping.
            var generatedSource =
                GenerateMapperSource(candidateName, modelName, dtoName, modelSymbol, dtoSymbol, namespaceName);
            context.AddSource($"{candidateName}.g.cs", SourceText.From(generatedSource, Encoding.UTF8));
        }
    }

    private string GenerateMapperSource(string candidateName, string modelName, string dtoName,
        INamedTypeSymbol modelSymbol, INamedTypeSymbol dtoSymbol, string namespaceName)
    {
        // Get public instance properties from model and dto types.
        var modelProperties = modelSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p is { IsStatic: false, DeclaredAccessibility: Accessibility.Public });
        var dtoProperties = dtoSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => p is { IsStatic: false, DeclaredAccessibility: Accessibility.Public })
            .ToDictionary(p => p.Name);

        // Build the assignments for mapping from model to dto.
        var modelToDtoAssignments = new StringBuilder();
        var propertySymbols = modelProperties.ToList();
        foreach (var prop in propertySymbols)
        {
            if (!dtoProperties.TryGetValue(prop.Name, out var dtoProp))
                continue;
            // Map the property if types are exactly equal.
            if (SymbolEqualityComparer.Default.Equals(prop.Type, dtoProp.Type))
            {
                modelToDtoAssignments.AppendLine($"                {prop.Name} = model.{prop.Name},");
            }
        }

        // Build the assignments for mapping from dto to model.
        var dtoToModelAssignments = new StringBuilder();
        foreach (var prop in dtoProperties.Values)
        {
            // Check if the model has a matching writable property.
            var modelProp = propertySymbols.FirstOrDefault(p => p.Name == prop.Name);
            if (modelProp != null && SymbolEqualityComparer.Default.Equals(modelProp.Type, prop.Type))
            {
                dtoToModelAssignments.AppendLine($"            model.{prop.Name} = dto.{prop.Name};");
            }
        }

        // Generate the source code for the mapper implementation.
        var source = $$"""

                       using System;
                       using System.Collections.Generic;
                       using System.Linq;
                       using QuickAPI.Core;
                       using QuickAPI.Database.DataModels;
                       using QuickAPI.Shared.Dtos;

                       namespace {{namespaceName}}
                       {
                           public partial class {{candidateName}} : IModelDtoMapper<{{modelName}}, {{dtoName}}>
                           {
                               public {{dtoName}} MapToDto({{modelName}} model)
                               {
                                   return new {{dtoName}}
                                   {
                       {{modelToDtoAssignments}}
                                   };
                               }
                       
                               public {{modelName}} MapToModel({{dtoName}} dto, {{modelName}} model = null)
                               {
                                   model = model ?? new {{modelName}}();
                       {{dtoToModelAssignments}}
                                   return model;
                               }
                       
                               public IEnumerable<{{dtoName}}> MapToDtos(IEnumerable<{{modelName}}> models)
                               {
                                   return models.Select(MapToDto);
                               }
                       
                               public IEnumerable<{{modelName}}> MapToModels(IEnumerable<{{dtoName}}> dtos)
                               {
                                   return dtos.Select(dto => MapToModel(dto));
                               }
                           }
                       }

                       """;
        return source;
    }

    // Helper method to search the compilation's global namespace for a type with the specified name.
    private INamedTypeSymbol? FindTypeByName(Compilation compilation, string typeName)
    {
        return FindTypeInNamespace(compilation.GlobalNamespace, typeName);
    }

    private INamedTypeSymbol? FindTypeInNamespace(INamespaceSymbol namespaceSymbol, string typeName)
    {
        foreach (var member in namespaceSymbol.GetMembers())
        {
            switch (member)
            {
                case INamespaceSymbol ns:
                {
                    var result = FindTypeInNamespace(ns, typeName);
                    if (result != null)
                        return result;
                    break;
                }
                case INamedTypeSymbol type when type.Name == typeName:
                    return type;
            }
        }

        return null;
    }

    // The syntax receiver collects candidate partial classes that start with "AutoMapperFor_".
    class MapperSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateMapperDeclarations { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax cds &&
                cds.Identifier.Text.StartsWith("AutoMapperFor_") &&
                cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
            {
                CandidateMapperDeclarations.Add(cds);
            }
        }
    }
}